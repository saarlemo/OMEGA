%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (C) 2022-2024 Ville-Veikko Wettenhovi
%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
% Public License for more details.
%
% You should have received a copy of the GNU General Public License along
% with this program. If not, see <https://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef projectorClass
    %PROJECTORCLASS A MATLAB class for computing the backward and
    %forward projections in OMEGA or forming the entire system matrix

    properties
        param
        nMeas
        nMeasSubset
        subset
        index
        trans
        x
        z
    end

    methods
        function obj = projectorClass(options, varargin)
            %PROJECTORCLASS Construct an instance of this class
            %   Input is the options struct generated by any of the
            %   main-files. All parameters should be adjusted in the
            %   corresponding main-file, though manual adjustment is also
            %   possible. However, the object should be always re-created
            %   after any parameters are changed, otherwise the
            %   reconstructions may not work or might produce wrong
            %   results.
            %
            %   Alternatively, the user can manually input the necessary
            %   variables. Two possibilities are available in this case.
            %   In the first case the inputs are the projection
            %   angles (also the total number of projections), number of
            %   rows in a projection, number of columns in a projection,
            %   image size, FOV sizes (mm), the detector pitch/size, source
            %   to detector distance (mm) and source to center of rotation
            %   distance (mm). Second possibility is to input manually the
            %   detector coordinates (x, y, and z coordinates). x should be
            %   horizontal and y the vertical, while z is the axial
            %   direction. These should be row vectors of size [N 2], i.e.
            %   with 2 columns. The source coordinates are assumed to be in
            %   the second column. The number of coordinates should equal
            %   the total number of projection bins (i.e. numel(x)/2 ==
            %   numel(projectionImages). The other inputs are the same as
            %   previously, except that sourceToDetector, sourceToCRot and
            %   dPitch are not needed.
            %
            %   When using manual inputs the projector is always improved
            %   Siddon. The number of subsets can be optionally specified,
            %   with the default being no subsets (i.e. subsets = 1).
            %   Default implementation is 4, but it can be changed to 3
            %   (OpenCL) in which case the default platform is 0, but this
            %   can be changed as well. Only one device is used at all
            %   times.
            %   Examples:
            %       proj = projectorClass(options);
            %       proj = projectorClass(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot);
            %       proj = projectorClass(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot,
            %           sourceOffsetRow, bedOffset);
            %       proj = projectorClass(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot,
            %           sourceOffsetRow, bedOffset, subsets);
            %       proj = projectorClass(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot,
            %           sourceOffsetRow, bedOffset, subsets, implementation, use_device);
            %       proj = projectorClass(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot,
            %           [], [], [], implementation, use_device);
            %       proj = projectorClass(x, y, z, Nx, Ny, Nz, FOV_tr, axial_fov, subsets, implementation, use_device);
            %   INPUTS:
            %       angles = The angles corresponding to the projections,
            %       can be either degrees or radians (degrees will be
            %       converted to radians). If you have multiple bed
            %       positions (step and shoot), then this must include the
            %       angles of each bed positions. E.g. if you have 2 bed
            %       positions with 50 projections each, then numel(angles)
            %       has to be 100 for correct operation. If each bed
            %       position uses the same angles, then simply use repmat
            %       to repeat the angles-vector (e.g. repmat(angles,
            %       nBedPositions,1), assuming a column vector).
            %       Prows = The number of rows in a single projection
            %       image.
            %       Pcolumns = The number of columns in a single projection
            %       image (if you use sinogram data, set this to 1).
            %       Nx = Image size (in voxels) in x-direction.
            %       Ny = Image size (in voxels) in y-direction.
            %       Nz = Image size (in voxels) in z-direction.
            %       FOV_tr = FOV size in transaxial direction (mm).
            %       axial_fov = FOV size in axial direction (mm). For 2D
            %       cases, use the detector pitch.
            %       dPitch = The detector/pixel pitch/size (mm).
            %       sourceToDetector = The (orthogonal) distance (in mm)
            %       from the source to the detector.
            %       sourceToCRot = The (orthogonal) distance (in mm)
            %       from the source to the center of rotation.
            %       sourceOffsetRow = (Optional) The horizontal offset of
            %       the source (mm). Can be a vector containing different
            %       offset for each projection. Default is 0.
            %       bedOffset = (Optional) The different offsets for the
            %       bed positions. The number of bed bed positions is
            %       assumed to be the number of offset values (first should
            %       be 0). Default is scalar 0.
            %       subsets = (Optional) Number of subsets. Default is 1.
            %       implementation = (Optional) Implementation to use (1, 3
            %       and 4 are supported). Default is 4.
            %       use_device = (Optional) (Implementation 3 only) the
            %       OpenCL platform used. Default is 0.
            %       x = x (horizontal/column) coordinates (mm)
            %       y = y (vertical/row) coordinates (mm)
            %       z = z (axial) coordinates (mm)
            %
            % OUTPUTS:
            %       proj = The class object.

            if nargin > 1 && isvector(options) && isscalar(varargin{1})
                obj.param.angles = options;
                obj.param.nRowsD = varargin{1};
                obj.param.nColsD = varargin{2};
                obj.param.Nx = varargin{3}(1);
                obj.param.Ny = varargin{3}(2);
                obj.param.Nz = varargin{3}(3);
                obj.param.FOVa_x = varargin{4};
                obj.param.FOVa_y = obj.param.FOVa_x;
                obj.param.axial_fov = varargin{5};
                obj.param.dPitchX = varargin{6};
                obj.param.dPitchY = obj.param.dPitchX;
                obj.param.sourceToDetector = varargin{7};
                obj.param.sourceToCRot = varargin{8};
                if nargin >= 10 && ~isempty(varargin{9})
                    obj.param.oOffsetX = varargin{9}(1);
                    obj.param.oOffsetY = varargin{9}(2);
                    obj.param.oOffsetZ = varargin{9}(3);
                end
                if nargin >= 11 && ~isempty(varargin{10})
                    obj.param.sourceOffsetRow = varargin{10}(1);
                    obj.param.sourceOffsetCol = varargin{10}(2);
                end
                if nargin >= 12 && ~isempty(varargin{11})
                    obj.param.detOffsetRow = varargin{11}(1);
                    obj.param.detOffsetCol = varargin{11}(2);
                end
                if nargin >= 13 && ~isempty(varargin{12})
                    obj.param.subsets = varargin{12};
                else
                    obj.param.subsets = 1;
                end
                if nargin >= 14 && ~isempty(varargin{13})
                    obj.param.implementation = varargin{13};
                else
                    obj.param.implementation = 4;
                end
                if nargin >= 15 && ~isempty(varargin{14})
                    obj.param.use_device = varargin{14};
                else
                    obj.param.use_device = 0;
                end
                obj.param.nProjections = numel(obj.param.angles);
                obj.param.subset_type = 8;
                obj.param.projector_type = 4;
                obj.param.simple = true;
                obj.param.CT = true;
            elseif nargin > 1 && (ismatrix(options) || isvector(options)) && (ismatrix(varargin{1}) || isvector(varargin{1})) && isscalar(varargin{3})
                obj.param.x = options;
                obj.param.y = varargin{1};
                obj.param.z = varargin{2};
                if isvector(obj.param.x)
                    obj.param.x = reshape(obj.param.x, [], 2);
                end
                if isvector(obj.param.y)
                    obj.param.y = reshape(obj.param.y, [], 2);
                end
                if isvector(obj.param.z)
                    obj.param.z = reshape(obj.param.z, [], 2);
                end
                obj.param.Nx = varargin{3}(1);
                obj.param.Ny = varargin{3}(2);
                obj.param.Nz = varargin{3}(3);
                obj.param.FOVa_x = varargin{4};
                obj.param.FOVa_y = obj.param.FOVa_x;
                obj.param.axial_fov = varargin{5};
                if nargin >= 7 && ~isempty(varargin{6})
                    obj.param.subsets = varargin{6};
                else
                    obj.param.subsets = 1;
                end
                if nargin >= 8 && ~isempty(varargin{7})
                    obj.param.implementation = varargin{7};
                else
                    obj.param.implementation = 4;
                end
                if nargin >= 9 && ~isempty(varargin{8})
                    obj.param.use_device = varargin{8};
                else
                    obj.param.use_device = 0;
                end
                if nargin >= 10 && ~isempty(varargin{9})
                    obj.param.CT = varargin{9};
                    obj.param.PET = ~varargin{9};
                else
                    obj.param.CT = false;
                    obj.param.PET = true;
                end
                obj.param.subset_type = 1;
                obj.param.simple = true;
            elseif nargin > 1 && (ismatrix(options) || isvector(options)) && (ismatrix(varargin{1}) || isvector(varargin{1})) && (ismatrix(varargin{3}) || isvector(varargin{3}))
                obj.param.x = options;
                obj.param.y = varargin{1};
                obj.param.z = varargin{2};
                if isvector(obj.param.x)
                    obj.param.x = reshape(obj.param.x, [], 2);
                end
                if isvector(obj.param.y)
                    obj.param.y = reshape(obj.param.y, [], 2);
                end
                if isvector(obj.param.z)
                    obj.param.z = reshape(obj.param.z, [], 2);
                end
                obj.param.uV = varargin{3};
                if size(obj.param.uV,1) == 2 || size(obj.param.uV) == 6
                else
                    obj.param.uV = reshape(obj.param.uV, [], numel(obj.param.x) / 2);
                end
                obj.param.Nx = varargin{4}(1);
                obj.param.Ny = varargin{4}(2);
                obj.param.Nz = varargin{4}(3);
                obj.param.FOVa_x = varargin{5};
                obj.param.FOVa_y = obj.param.FOVa_x;
                obj.param.axial_fov = varargin{6};
                obj.param.oOffsetX = varargin{7}(1);
                obj.param.oOffsetY = varargin{7}(2);
                obj.param.oOffsetZ = varargin{7}(3);
                obj.param.nRowsD = varargin{8}(1);
                obj.param.nColsD = varargin{8}(2);
                obj.param.dPitchX = varargin{9}(1);
                obj.param.dPitchY = varargin{9}(2);
                if nargin >= 11 && ~isempty(varargin{10})
                    obj.param.projector_type = varargin{10};
                else
                    obj.param.projector_type = 4;
                end
                if nargin >= 12 && ~isempty(varargin{11})
                    obj.param.subsets = varargin{11};
                else
                    obj.param.subsets = 1;
                end
                obj.param.implementation = 3;
                if nargin >= 13 && ~isempty(varargin{12})
                    obj.param.use_device = varargin{12};
                else
                    obj.param.use_device = 0;
                end
                obj.param.nProjections = numel(obj.param.x) / 2;
                obj.param.dL = obj.param.FOVa_x / obj.param.Nx / 1;
                obj.param.sourceToDetector = mean(sqrt((obj.param.x(:,1) - obj.param.x(:,2)).^2 + (obj.param.y(:,1) - obj.param.y(:,2)).^2 ....
                    + (obj.param.z(:,1) - obj.param.z(:,2)).^2));
                obj.param.simple = true;
                obj.param.CT = true;
            else
                obj.param = options;
                obj.param.simple = false;
            end
            obj.param = setMissingValues(obj.param);

            if (isfield(obj.param,'useSingles') && obj.param.useSingles) || obj.param.implementation == 5 || obj.param.implementation == 3 || obj.param.implementation == 2
                if isfield(obj.param,'useSingles') && obj.param.useSingles && obj.param.implementation == 1
                    obj.param.useSingles = false;
                    obj.param.cType = 'double';
                else
                    obj.param.useSingles = true;
                    obj.param.cType = 'single';
                end
            else
                obj.param.cType = 'double';
            end
            if obj.param.CT
                if isfield(obj.param, 'dPitch') && obj.param.dPitch > 0 && obj.param.dPitchX == 0
                    obj.param.dPitchX = obj.param.dPitch;
                end
                if isfield(obj.param, 'dPitch') && obj.param.dPitch > 0 && obj.param.dPitchY == 0
                    obj.param.dPitchY = obj.param.dPitch;
                end
                if isfield(obj.param,'NSinos') && (~isfield(obj.param,'nProjections') || obj.param.nProjections == 0)
                    obj.param.nProjections = obj.param.NSinos;
                else
                    obj.param.NSinos = obj.param.nProjections;
                end
                obj.param.TotSinos = obj.param.nProjections;
                obj.param.span = 3;
                if isfield(obj.param,'Ndist') && (~isfield(obj.param,'nRowsD') || obj.param.nRowsD == 0)
                    obj.param.nRowsD = obj.param.Ndist;
                else
                    obj.param.Ndist = obj.param.nRowsD;
                end
                if isfield(obj.param,'Nang') && (~isfield(obj.param,'nColsD') || obj.param.nColsD == 0)
                    obj.param.nColsD = obj.param.Nang;
                else
                    obj.param.Nang = obj.param.nColsD;
                end
                obj.param.use_raw_data = false;
                obj.param.attenuation_correction = false;
                obj.param.normalization_correction = false;
                obj.param.compute_normalization = false;
                obj.param.rings = obj.param.nColsD * obj.param.nBed;
                obj.param.det_per_ring = obj.param.nRowsD * obj.param.nProjections;
                obj.param.arc_correction = false;
                obj.param.det_w_pseudo = obj.param.det_per_ring;
                obj.param.cryst_per_block = obj.param.nColsD * obj.param.nRowsD;
                if isfield(obj.param, 'dPitch') && obj.param.dPitch > 0
                    obj.param.cr_pz = obj.param.dPitch;
                elseif isfield(obj.param, 'dPitchY')
                    obj.param.cr_pz = obj.param.dPitchY;
                elseif isfield(obj.param, 'cr_pz')
                    obj.param.dPitchY = obj.param.cr_pz;
                end
                if isfield(obj.param, 'dPitch') && obj.param.dPitch > 0
                    obj.param.cr_p = obj.param.dPitch;
                elseif isfield(obj.param, 'dPitchX')
                    obj.param.cr_p = obj.param.dPitchX;
                elseif isfield(obj.param, 'cr_p')
                    obj.param.dPitchX = obj.param.cr_p;
                end
                if isfield(obj.param,'angles') && max(abs(obj.param.angles(:))) > 6*pi
                    obj.param.angles = obj.param.angles * (pi / 180);
                end
                if isfield(obj.param,'angles') && obj.param.offangle > 0
                    obj.param.angles = obj.param.angles + obj.param.offangle;
                end

                if ~isfield(obj.param, 'x') || (isfield(obj.param, 'x') && numel(obj.param.x) == 2 * obj.param.nProjections)
                    obj.param = setCTCoordinates(obj.param);
                    obj.param.y = cast(obj.param.y, obj.param.cType);
                    obj.param.z = cast(obj.param.z, obj.param.cType);
                end
                if ~isa(obj.param.x, obj.param.cType)
                    obj.param.x = cast(obj.param.x, obj.param.cType);
                end
            end
            obj.param = convertOptions(obj.param);
            if ~obj.param.simple && obj.param.errorChecking
                obj.param = OMEGA_error_check(obj.param);
            end
            % Is TOF enabled?
            obj.param.TOF = obj.param.TOF_bins > 1 && (obj.param.projector_type == 1 || obj.param.projector_type == 11 || obj.param.projector_type == 3 || obj.param.projector_type == 33 ...
                || obj.param.projector_type == 13 || obj.param.projector_type == 31 || obj.param.projector_type == 4 || obj.param.projector_type == 14 || obj.param.projector_type == 41 ...
                || obj.param.projector_type == 44);
            if ~obj.param.TOF && obj.param.TOF_bins_used > 1
                warning('TOF selected, but not supported with the current options!')
            end
            % Special requirements for span 1 case
            if obj.param.span == 1
                obj.param.TotSinos = obj.param.rings^2 * obj.param.nLayers^2;
                obj.param.NSinos = obj.param.TotSinos;
            end
            if (~obj.param.CT && ~obj.param.SPECT)
                if isfield(obj.param,'NSinos') && obj.param.NSinos > 0
                    obj.param.nProjections = obj.param.NSinos;
                else
                    obj.param.NSinos = obj.param.nProjections;
                end
                if isfield(obj.param,'Ndist') && obj.param.Ndist > 0
                    obj.param.nRowsD = obj.param.Ndist;
                else
                    obj.param.Ndist = obj.param.nRowsD;
                end
                if isfield(obj.param,'Nang') && obj.param.Nang > 0
                    obj.param.nColsD = obj.param.Nang;
                else
                    obj.param.Nang = obj.param.nColsD;
                end
            end
            if (~obj.param.CT && ~obj.param.SPECT) && ((obj.param.subset_type > 7 && obj.param.subsets > 1) || obj.param.subsets == 1)
                obj.param.PET = true;
            else
                obj.param.PET = false;
            end
            var = recNames(2);
            ll = 0;
            kk = 1;
            while ll == 0 && kk <= numel(var)
                ll = ll + obj.param.(var{kk});
                kk = kk + 1;
            end
            obj.param.MAP = ll > 0;

            if isfield(obj.param, 'maskFP') && numel(obj.param.maskFP) > 1 && ((numel(obj.param.maskFP) ~= obj.param.nRowsD * obj.param.nColsD && numel(obj.param.maskFP) ~= obj.param.nRowsD * obj.param.nColsD * obj.param.nProjections && (obj.param.CT || obj.param.SPECT)) || (numel(obj.param.maskFP) ~= obj.param.Nang * obj.param.Ndist && numel(obj.param.maskFP) ~= obj.param.Nang * obj.param.Ndist * obj.param.NSinos && ~obj.param.CT))
                if obj.param.CT || obj.param.SPECT
                    error(['Incorrect size for the forward projection mask! Must be the size of a single projection image [' num2str(obj.param.nRowsD) ' ' num2str(obj.param.nColsD) '] or full stack of [' num2str(obj.param.nRowsD) ' ' num2str(obj.param.nColsD)  ' ' num2str(obj.param.nProjections) ']'])
                else
                    error(['Incorrect size for the forward projection mask! Must be the size of a single sinogram image [' num2str(obj.param.nRowsD) ' ' num2str(obj.param.nColsD) '] or all sinograms [' num2str(obj.param.nRowsD) ' ' num2str(obj.param.nColsD) ' ' num2str(obj.param.NSinos) ']'])
                end
            elseif isfield(obj.param, 'maskFP') && numel(obj.param.maskFP) > 1 && (numel(obj.param.maskFP) == obj.param.nRowsD * obj.param.nColsD || numel(obj.param.maskFP) == obj.param.nRowsD * obj.param.nColsD * obj.param.nProjections)
                obj.param.useMaskFP = true;
                obj.param.maskFPZ = size(obj.param.maskFP,3);
            else
                obj.param.useMaskFP = false;
            end
            if isfield(obj.param, 'maskBP') && numel(obj.param.maskBP) > 1 && (numel(obj.param.maskBP) ~= obj.param.Nx(1) * obj.param.Ny(1) && numel(obj.param.maskBP) ~= obj.param.Nx(1) * obj.param.Ny(1) * obj.param.Nz(1))
                error(['Incorrect size for the backward projection mask! Must be the size of a single image [' num2str(obj.param.Nx(1)) ' ' num2str(obj.param.Ny(1)) '] or 3D stack [' num2str(obj.param.Nx(1)) ' ' num2str(obj.param.Ny(1)) ' ' num2str(obj.param.Nz(1)) ']'])
            elseif isfield(obj.param, 'maskBP') && (numel(obj.param.maskBP) ~= obj.param.Nx(1) * obj.param.Ny(1) || numel(obj.param.maskBP) ~= obj.param.Nx(1) * obj.param.Ny(1) * obj.param.Nz(1))
                obj.param.useMaskBP = true;
                obj.param.maskBPZ = size(obj.param.maskBP,3);
            else
                obj.param.useMaskBP = false;
            end
            rings = obj.param.rings;
            if obj.param.use_raw_data && isfield(obj.param,'x')
                det_per_ring = numel(obj.param.x);
            else
                det_per_ring = obj.param.det_per_ring;
            end
            if obj.param.use_raw_data
                rings = rings - sum(obj.param.pseudot);
                obj.param.rings = rings;
                obj.param.detectors = det_per_ring * rings;
            end
            if ~isfield(obj.param, 'global_correction_factor') || isempty(obj.param.global_correction_factor)
                obj.param.global_correction_factor = 1;
            end
            obj.param.tr_offsets = 0;
            list_mode_format = false;
            % TOF parameters
            % Initial work on TOF by Jonna Kangasniemi
            if obj.param.TOF
                if obj.param.TOF_bins_used ~= obj.param.TOF_bins
                    obj.param.sigma_x = 0;
                    TOFCenter = 0;
                else
                    c = 2.99792458e11;
                    obj.param.sigma_x = (c*obj.param.TOF_FWHM/2) / (2 * sqrt(2 * log(2)));
                    edges_user = linspace(-obj.param.TOF_width * obj.param.TOF_bins/2, obj.param.TOF_width * obj.param.TOF_bins / 2, obj.param.TOF_bins + 1);
                    edges_user = edges_user(1:end-1) + obj.param.TOF_width/2; % the most probable value where annihilation occured
                    TOFCenter = zeros(size(edges_user));
                    TOFCenter(1) = edges_user(ceil(length(edges_user)/2));
                    TOFCenter(2:2:end) = edges_user(ceil(length(edges_user)/2) + 1:end);
                    TOFCenter(3:2:end) = edges_user(ceil(length(edges_user)/2) - 1: -1 : 1);
                    if isfield(obj.param, 'TOF_offset') && obj.param.TOF_offset > 0
                        TOFCenter = TOFCenter + obj.param.TOF_offset;
                    end
                    TOFCenter = -TOFCenter * c / 2;
                end
            else
                obj.param.sigma_x = 0;
                TOFCenter = 0;
            end
            obj.param.TOFCenter = cast(TOFCenter, obj.param.cType);
            
            temp = obj.param.pseudot;
            if ~isempty(temp) && temp > 0
                for kk = uint32(1) : temp
                    obj.param.pseudot(kk) = uint32(obj.param.cryst_per_block + 1) * kk;
                end
            elseif temp == 0
                obj.param.pseudot = [];
            end

            if obj.param.implementation == 1
                obj.param.precompute_lor = true;
            else
                obj.param.precompute_lor = false;
            end

            % Whether list-mode or sinogram/raw data is used
            if (isfield(obj.param,'x') || isfield(obj.param,'y') || (isfield(obj.param,'z') || isfield(obj.param,'z_det'))) && (numel(obj.param.x) / 2 == numel(obj.param.SinM) || numel(obj.param.x) / 6 == numel(obj.param.SinM))
                det_per_ring = numel(obj.param.SinM);
                obj.param.Nang = 1;
                obj.param.Ndist = 1;
                obj.param.NSinos = det_per_ring;
                obj.param.TotSinos = obj.param.NSinos;
                list_mode_format = true;
                obj.param.listmode = true;
            elseif isfield(obj.param,'trIndex') && obj.param.useIndexBasedReconstruction
                det_per_ring = numel(obj.param.trIndex) / 2;
                obj.param.Nang = 1;
                obj.param.Ndist = 1;
                obj.param.NSinos = det_per_ring;
                obj.param.TotSinos = obj.param.NSinos;
                list_mode_format = true;
                obj.param.listmode = true;
            else
                % Compute the indices for the subsets used.
                % For Sinogram data, six different methods to select the subsets are
                % available. For raw data, three methods are available.
                obj.param.listmode = false;
            end
            if obj.param.listmode && obj.param.subsets > 1 && obj.param.subset_type ~= 1 && obj.param.subset_type ~= 3 && obj.param.subset_type ~= 0
                warning('Only subset types 0, 1, and 3 are supported with list-mode/custom detector data! Switching to subset type 0.')
                obj.param.subset_type = 0;
            end
            [obj.index, obj.nMeas, obj.param.subsets] = index_maker(obj.param);

            obj.param = setUpCorrections(obj.param);

            % Coordinates of the detectors
            if obj.param.projector_type ~= 6
                if ~obj.param.listmode
                    if (obj.param.SPECT)
                        [x_det, z_det] = get_coordinates_SPECT(obj.param);
                        y = 0;
                    else
                        [x_det, y, z_det, obj.param] = get_coordinates(obj.param, obj.param.rings, obj.param.pseudot);
                    end
                else
                    if ~obj.param.useIndexBasedReconstruction
                        if size(obj.param.x,2) == 2
                            obj.param.x = [obj.param.x(:,1)'; obj.param.y(:,1)'; obj.param.z(:,1)';obj.param.x(:,2)'; obj.param.y(:,2)'; obj.param.z(:,2)'];
                        elseif size(obj.param.x,1) == 2
                            obj.param.x = [obj.param.x(:,1); obj.param.y(:,1); obj.param.z(:,1);obj.param.x(:,2); obj.param.y(:,2); obj.param.z(:,2)];
                        end
                    end
                    y = 0;
                    x_det = 0;
                    z_det = 0;
                end
            else
                y = 0;
                x_det = 0;
                z_det = 0;
            end

            if obj.param.use_raw_data
                if list_mode_format
                    if ~obj.param.useIndexBasedReconstruction
                        size_x = uint32(numel(obj.param.x) / 6);
                    else
                        size_x = uint32(numel(obj.param.x) / 2);
                    end
                else
                    size_x = uint32(numel(x_det));
                end
            else
                if list_mode_format
                    if ~obj.param.useIndexBasedReconstruction
                        size_x = uint32(numel(obj.param.x) / 6);
                    else
                        size_x = uint32(numel(obj.param.x) / 2);
                    end
                else
                    size_x = uint32(obj.param.Ndist);
                end
                if obj.param.sampling > 1 && ~obj.param.precompute_lor
                    size_x = size_x * obj.param.sampling;
                end
            end
            if obj.param.CT || obj.param.projector_type == 6
                size_x = uint32(obj.param.nRowsD);
                obj.param.size_y = uint32(obj.param.nColsD);
                if obj.param.listmode
                    size_x = uint32(numel(obj.param.x) / 6);
                end
            else
                obj.param.angles = 0;
                obj.param.dPitch = obj.param.cr_p;
                obj.param.dPitchY = obj.param.cr_p;
                obj.param.dPitchX = obj.param.cr_pz;
                obj.param.size_y = obj.param.Nang;
                obj.param.nProjections = obj.param.NSinos;
                obj.param.nRowsD = obj.param.Ndist;
                obj.param.nColsD = obj.param.Nang;
            end
            obj.param.size_x = size_x;
            obj.param.totMeas = obj.param.nColsD * obj.param.nRowsD * obj.param.nProjections;

            obj.nMeas = [int64(0);int64(cumsum(obj.nMeas))];
            if iscell(obj.index)
                obj.index = cell2mat(obj.index);
            end

            [xx,yy,zz,obj.param.dx,obj.param.dy,obj.param.dz,obj.param.bx,obj.param.by,obj.param.bz] = computePixelSize([obj.param.FOVa_x; obj.param.FOVa_y; obj.param.axial_fov], [obj.param.Nx; obj.param.Ny; obj.param.Nz], ...
                [obj.param.oOffsetX; obj.param.oOffsetY; obj.param.oOffsetZ], obj.param.cType);
            obj.param.Nx = uint32(obj.param.Nx);
            obj.param.Ny = uint32(obj.param.Ny);
            obj.param.Nz = uint32(obj.param.Nz);


            if obj.param.use_raw_data
                obj.param.LL = form_detector_pairs_raw(obj.param.rings, obj.param.det_per_ring);
            else
                obj.param.LL = uint16([]);
            end
            if obj.param.implementation == 1
                folder = fileparts(which('projectorClass.m'));
                folder = [folder(1:end-(6 + 8)), 'mat-files/'];
                folder = strrep(folder, '\','/');
                if obj.param.use_raw_data
                    if isempty(obj.param.machine_name)
                        file_string = [folder obj.param.name '_detector_locations_' num2str(obj.param.Nx) 'x' num2str(obj.param.Ny) 'x' num2str(obj.param.Nz) '_raw_' num2str(det_per_ring) 'x' num2str(obj.param.rings) '.mat'];
                    else
                        file_string = [folder obj.param.machine_name '_detector_locations_' num2str(obj.param.Nx) 'x' num2str(obj.param.Ny) 'x' num2str(obj.param.Nz) '_raw_' num2str(det_per_ring) 'x' num2str(obj.param.rings) '.mat'];
                    end
                else %% Sinogram data
                    if isempty(obj.param.machine_name)
                        file_string = [folder obj.param.name '_lor_pixel_count_' num2str(obj.param.Nx) 'x' num2str(obj.param.Ny) 'x' num2str(obj.param.Nz) '_FOV' num2str(obj.param.FOVa_x) 'x' num2str(obj.param.FOVa_y) 'x' num2str(obj.param.axial_fov) '_sino_' num2str(obj.param.Ndist) 'x' ...
                            num2str(obj.param.Nang) 'x' num2str(obj.param.TotSinos) '.mat'];
                    else
                        file_string = [folder obj.param.machine_name '_lor_pixel_count_' num2str(obj.param.Nx) 'x' num2str(obj.param.Ny) 'x' num2str(obj.param.Nz) '_FOV' num2str(obj.param.FOVa_x) 'x' num2str(obj.param.FOVa_y) 'x' num2str(obj.param.axial_fov) '_sino_' num2str(obj.param.Ndist) 'x' ...
                            num2str(obj.param.Nang) 'x' num2str(obj.param.TotSinos) '.mat'];
                    end
                end
                if exist(file_string,"file") ~= 2
                    obj.param.lor_a = lor_pixel_count_prepass(obj.param, z_det, x_det, obj.param.LL);
                else
                    obj.param.lor_a = loadStructFromFile(file_string, 'lor');
                end
            else
                obj.param.lor_a = uint16([]);
            end

            if ~obj.param.precompute_lor
                obj.param.lor_a = uint16(0);
            end
            if obj.param.use_raw_data
                obj.param.LL = form_detector_pairs_raw(obj.param.rings, obj.param.det_per_ring);
            else
                obj.param.LL = uint16([]);
            end

            % Compute the necessary indices required for subsets (e.g. the index of
            % the detector coordinates for the current LOR)
            % if ~list_mode_format
            [obj.param, obj.param.lor_a, obj.param.xy_index, obj.param.z_index, obj.param.LL, obj.param.summa] = form_subset_indices(obj.param, obj.nMeas, obj.index, y, ...
                obj.param.lor_a, obj.param.LL);
            if obj.param.listmode
            elseif obj.param.CT || obj.param.PET || (obj.param.SPECT && obj.param.projector_type ~= 6)
                if obj.param.subset_type >= 8 && obj.param.subsets > 1 && ~obj.param.FDK
                    if obj.param.CT || obj.param.SPECT
                        x_det = reshape(x_det, 6, obj.param.nProjections);
                        x_det = x_det(:,obj.index);
                        x_det = x_det(:);
                        if obj.param.pitch
                            z_det = reshape(z_det, 6, obj.param.nProjections);
                            z_det = z_det(:,obj.index);
                            z_det = z_det(:);
                        else
                            z_det = reshape(z_det, 2, obj.param.nProjections);
                            z_det = z_det(:,obj.index);
                            z_det = z_det(:);
                        end
                    else
                        z_det = reshape(z_det, [], obj.param.nProjections);
                        z_det = z_det(:,obj.index);
                        z_det = z_det(:);
                    end
                    if obj.param.CT
                        obj.param.uV = obj.param.uV(:,obj.index);
                    end
                end
            end
            if ~obj.param.listmode
                obj.x = x_det;
                obj.z = z_det;
            elseif obj.param.useIndexBasedReconstruction
                obj.x = cast(obj.param.x, obj.param.cType);
                obj.z = cast(obj.param.z, obj.param.cType);
            else
                if isfield(obj.param,'y')
                    obj.param = rmfield(obj.param, 'y');
                end
                if isfield(obj.param,'z')
                    obj.param = rmfield(obj.param, 'z');
                elseif isfield(obj.param,'z_det')
                    obj.param = rmfield(obj.param, 'z_det');
                end
            end
            obj.param.N = uint64(obj.param.Nx).*uint64(obj.param.Ny).*uint64(obj.param.Nz);

            [obj.param.x_center,obj.param.y_center,obj.param.z_center] = computePixelCenters(xx,yy,zz,obj.param.dx,obj.param.dy,obj.param.dz,obj.param.TOF,obj.param);

            [obj.param.V,obj.param.Vmax,obj.param.bmin,obj.param.bmax] = computeVoxelVolumes(obj.param.dx,obj.param.dy,obj.param.dz,obj.param);


            if (obj.param.projector_type == 2 || obj.param.projector_type == 3 || obj.param.projector_type == 22 || obj.param.projector_type == 33)
                if obj.param.projector_type == 3 || obj.param.projector_type == 33
                    obj.param.orthTransaxial = true;
                elseif (obj.param.projector_type == 2 || obj.param.projector_type == 22) && (isfield(options,'tube_width_xy') && options.tube_width_xy > 0 || options.SPECT)
                    obj.param.orthTransaxial = true;
                else
                    obj.param.orthTransaxial = false;
                end
            else
                obj.param.orthTransaxial = false;
            end
            if (obj.param.projector_type == 2 || obj.param.projector_type == 3 || obj.param.projector_type == 22 || obj.param.projector_type == 33)
                if obj.param.projector_type == 3 || obj.param.projector_type == 33
                    obj.param.orthAxial = true;
                elseif (obj.param.projector_type == 2 || obj.param.projector_type == 22) && (isfield(obj.param,'tube_width_z') && obj.param.tube_width_z > 0 || options.SPECT)
                    obj.param.orthAxial = true;
                else
                    obj.param.orthAxial = false;
                end
            else
                obj.param.orthAxial = false;
            end

            if ((obj.param.projector_type == 2 || obj.param.projector_type == 3 || obj.param.projector_type == 22 || obj.param.projector_type == 33) && obj.param.SPECT)
                obj.param = SPECTParameters(obj.param);
            end

            if obj.param.projector_type == 4 || obj.param.projector_type == 5 || obj.param.projector_type == 14 || obj.param.projector_type == 41 ...
                    || obj.param.projector_type == 15 || obj.param.projector_type == 45 || obj.param.projector_type == 54 || obj.param.projector_type == 51 ...
                    || obj.param.projector_type == 42 || obj.param.projector_type == 43 || obj.param.projector_type == 24 || obj.param.projector_type == 34
                obj.param = computeProjectorScalingValues(obj.param);
            end

            if obj.param.use_raw_data && obj.param.sampling_raw > 1
                obj.param.det_per_ring = obj.param.det_per_ring * obj.param.sampling_raw;
            end

            if obj.param.offsetCorrection && obj.param.subsets > 1
                obj.param.OffsetLimit = obj.param.OffsetLimit(obj.index);
            end

            if obj.param.projector_type == 6
                obj.param = SPECTParameters(obj.param);
                if obj.param.subsets > 1 && (obj.param.subset_type == 8 || obj.param.subset_type == 9 || obj.param.subset_type == 10 || obj.param.subset_type == 11)
                    obj.param.angles = obj.param.angles(obj.index);
                    obj.param.blurPlanes = obj.param.blurPlanes(obj.index);
                    obj.param.gFilter = obj.param.gFilter(:,:,:,obj.index);
                end
            end
            %% This part is used when the observation matrix is calculated on-the-fly

            if length(obj.nMeas) == 1
                obj.nMeas = [int64(0);obj.nMeas];
            end

            if obj.param.subsets > 1
                obj.subset = 1;
            end
            if obj.param.subset_type >= 8 || obj.param.subsets == 1
                kerroin = obj.param.nColsD * obj.param.nRowsD;
            else
                kerroin = 1;
            end
            obj.nMeasSubset = zeros(obj.param.subsets, 1);
            for kk = 1 : obj.param.subsets
                obj.nMeasSubset(kk) = obj.nMeas(kk + 1) * kerroin - obj.nMeas(kk) * kerroin;
            end

            % Compute PSF kernel
            [gaussK, obj.param] = PSFKernel(obj.param);
            obj.param.gaussK = gaussK;
            if obj.param.listmode
                if ~isa(obj.param.x, obj.param.cType)
                    obj.param.x = cast(obj.param.x, obj.param.cType);
                end
                obj.param.randoms_correction = false;
                obj.param.scatter_correction = false;
            end
            if ~isfield(obj.param, 'ScatterC')
                obj.param.ScatterC = zeros(1,1, obj.param.cType);
            end

            obj.trans = false;

            obj.param.use_device = uint32(obj.param.use_device);
        end

        function obj = initCorrections(obj)
            [~, ~, obj.param] = loadCorrections(obj.param, [], []);
        end


        function y = forwardProject(obj, input, varargin)
            %FORWARDPROJECT Computes the forward projection between the
            %object and the input vector.
            %   Output is stored in the y-vector. PSF blurring is performed
            %   if it has been selected.
            % Inputs:
            %   obj = The projectorClass object created by projectorClass
            %   input = The input vector, i.e. this computes A * input
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            %   corrVec = Any multiplicative correction vector to be
            %   applied during the computation of the forward projector
            % Outputs:
            %   y = The result of y = A * input

            if nargin >=3 && ~isempty(varargin{1})
                obj.subset = varargin{1};
                if obj.subset <= 0
                    obj.subset = 1;
                    obj.param.useSubsets = false;
                else
                    obj.param.useSubsets = true;
                end
            elseif obj.param.subsets == 1 || isempty(obj.param.subsets)
                obj.subset = 1;
                obj.param.useSubsets = false;
            elseif obj.param.subsets > 1 && ~isempty(obj.subset) && obj.subset > 0
                obj.param.useSubsets = true;
            else
                obj.subset = 1;
                obj.param.useSubsets = false;
            end
            if nargin >= 4 && ~isempty(varargin{2})
                corrVec = varargin{2};
            else
                if obj.param.useSingles
                    corrVec = single([]);
                else
                    corrVec = [];
                end
            end
            if nargin >= 5 && ~isempty(varargin{3}) && varargin{3} > 0
                loopVar = varargin{3} : varargin{3};
            else
                loopVar = 1 : obj.param.nMultiVolumes + 1;
            end
            if obj.param.implementation == 3 || obj.param.implementation == 2 || obj.param.implementation == 5
                if isa(input,'double')
                    input = single(input);
                end
            else
                if obj.param.useSingles && isa(input,'double')
                    input = single(input);
                elseif ~obj.param.useSingles && isa(input,'single')
                    input = double(input);
                end
            end
            if obj.param.verbose > 1
                disp('Computing forward projection')
            end
            obj.param.currentSubset = obj.subset - 1;
            if obj.param.projector_type == 6
                obj.param.uu = obj.param.uu + obj.nMeas(obj.subset);
            end
            if obj.param.useSubsets
                if obj.param.implementation == 1 || obj.param.implementation == 4
                    [m_size, xy_index_input, z_index_input, L_input, lor_input, lor2, norm_input, corr_input] = splitInput(obj.param, obj.nMeas, obj.subset, obj.param.xy_index, obj.param.z_index, obj.param.LL, ...
                        obj.param.lor_a, corrVec);
                    [y, ~] = forwardProjection(obj.param, input, obj.x, obj.z, m_size, obj.nMeas(obj.subset), xy_index_input, z_index_input, norm_input, corr_input, L_input, obj.param.TOF, lor2, lor_input, obj.param.summa(obj.subset), loopVar, obj.subset - 1);
                else
                    [y, ~] = forwardProjection(obj.param, input, obj.x, obj.z, obj.nMeas, obj.nMeas, obj.param.xy_index, obj.param.z_index, obj.param.normalization, obj.param.ScatterC, obj.param.LL, obj.param.TOF, [], [], obj.param.summa, loopVar, obj.subset - 1);
                end
            else
                apu = 1;
                if obj.param.subsets > 1
                    apu = obj.param.subsets;
                    obj.param.subsets = 1;
                end
                if obj.param.implementation == 1
                    if exist('OCTAVE_VERSION','builtin') == 0
                        lor2 = [uint64(0);cumsum(uint64(obj.param.lor_a))];
                    else
                        lor2 = [uint64(0);cumsum(uint64(obj.param.lor_a),'native')];
                    end
                else
                    lor2 = [];
                end
                [y, ~] = forwardProjection(obj.param, input, obj.x, obj.z, obj.param.totMeas, obj.nMeas(end), obj.param.xy_index, obj.param.z_index, obj.param.normalization, corrVec, obj.param.LL, obj.param.TOF, lor2, ...
                    obj.param.lor_a, sum(obj.param.summa), loopVar, 0);
                if apu > 1
                    obj.param.subsets = apu;
                end
            end
            if obj.param.verbose > 0
                disp('Forward projection computed')
            end
        end


        function [f, varargout] = backwardProject(obj, input, varargin)
            %BACKWARDPROJECT Computes the backprojection between the object
            %and the input vector. Can also (optionally) compute the
            %sensitivity image.
            %   Output is stored in the f-vector. PSF blurring is performed
            %   if it has been selected.
            % Inputs:
            %   obj = The projectorClass object created by
            %   projectorClass
            %   input = The input vector, i.e. this computes A' * input
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            % Outputs:
            %   f = The result of f = A' * input
            %   sens = Sensitivity image. Can be omitted if sensitivity
            %   image is not required. 

            if nargin >=3 && ~isempty(varargin{1})
                obj.subset = varargin{1};
                if obj.subset <= 0
                    obj.subset = 1;
                    obj.param.useSubsets = false;
                else
                    obj.param.useSubsets = true;
                end
            elseif obj.param.subsets == 1 || isempty(obj.param.subsets)
                obj.subset = 1;
                obj.param.useSubsets = false;
            elseif obj.param.subsets > 1 && ~isempty(obj.subset) && obj.subset > 0
                obj.param.useSubsets = true;
            else
                obj.subset = 1;
                obj.param.useSubsets = false;
            end
            if nargin >= 4 && ~isempty(varargin{2})
                corrVec = varargin{2};
            else
                corrVec = [];
            end
            if nargout == 1
                noSensIm = true;
            else
                noSensIm = false;
            end
            obj.param.currentSubset = obj.subset - 1;
            if obj.param.projector_type == 6
                obj.param.ub = obj.param.ub + obj.nMeas(obj.subset);
            end
            if obj.param.implementation == 3 || obj.param.implementation == 2 || obj.param.implementation == 5
                if ~isa(input,'single')
                    input = single(input);
                end
            else
                if obj.param.useSingles && ~isa(input,'single')
                    input = single(input);
                elseif ~obj.param.useSingles && isa(input,'single')
                    input = double(input);
                end
            end
            if obj.param.verbose > 1
                disp('Computing backprojection')
            end
            if obj.param.useSubsets
                if obj.param.implementation == 1 || obj.param.implementation == 4
                    [m_size, xy_index_input, z_index_input, L_input, ~, ~, norm_input, corr_input] = splitInput(obj.param, obj.nMeas, obj.subset, obj.param.xy_index, obj.param.z_index, obj.param.LL, ...
                        obj.param.lor_a, corrVec);
                    if nargout == 2
                        [f, varargout{1}] = backwardProjection(obj.param, input, obj.x, obj.z, m_size, obj.nMeas(obj.subset), xy_index_input, z_index_input, norm_input, corr_input, L_input, obj.param.TOF, noSensIm, obj.subset - 1);
                    else
                        [f, ~] = backwardProjection(obj.param, input, obj.x, obj.z, m_size, obj.nMeas(obj.subset), xy_index_input, z_index_input, norm_input, corr_input, L_input, obj.param.TOF, noSensIm, obj.subset - 1);
                    end
                else
                    if nargout == 2
                        [f, varargout{1}] = backwardProjection(obj.param, input, obj.x, obj.z, obj.nMeas, obj.nMeas, obj.param.xy_index, obj.param.z_index, obj.param.normalization, obj.param.ScatterC, obj.param.LL, obj.param.TOF, noSensIm, obj.subset - 1);
                    else
                        [f, ~] = backwardProjection(obj.param, input, obj.x, obj.z, obj.nMeas, obj.nMeas, obj.param.xy_index, obj.param.z_index, obj.param.normalization, obj.param.ScatterC, obj.param.LL, obj.param.TOF, noSensIm, obj.subset - 1);
                    end
                end
            else
                apu = 1;
                if obj.param.subsets > 1
                    apu = obj.param.subsets;
                    obj.param.subsets = 1;
                end
                if nargout == 2
                    [f, varargout{1}] = backwardProjection(obj.param, input, obj.x, obj.z, obj.param.totMeas, obj.nMeas(end), obj.param.xy_index, obj.param.z_index, obj.param.normalization, corrVec, obj.param.LL, obj.param.TOF, noSensIm, 0);
                else
                    [f, ~] = backwardProjection(obj.param, input, obj.x, obj.z, obj.param.totMeas, obj.nMeas(end), obj.param.xy_index, obj.param.z_index, obj.param.normalization, corrVec, obj.param.LL, obj.param.TOF, noSensIm, 0);
                end
                if apu > 1
                    obj.param.subsets = apu;
                end
            end
            if obj.param.verbose > 0
                disp('Backprojection computed')
            end
        end
        function f = mtimes(obj, input)
            %MTIMES Automatically compute either the forward projection or
            %backprojection, based on the input vector length.
            %   Backprojection is selected if transpose operator is used.
            if obj.param.subsets > 1
                subs = obj.nMeasSubset(obj.subset);
            else
                subs = obj.param.totMeas;
            end
            if obj.trans == true || size(input,1) == subs || size(input,2) == subs || size(input,1) == subs * obj.param.TOF_bins || size(input,2) == subs * obj.param.TOF_bins
                if size(input,2) == subs || size(input,2) == subs * obj.param.TOF_bins
                    input = input';
                end
                f = backwardProject(obj, input);
            else
                f = forwardProject(obj, input);
            end
        end
        function A = formMatrix(obj, varargin)
            %FORMMATRIX Forms the TRANSPOSE of the system matrix for the
            %current subset or, if no subsets are used, the entire matrix
            %   Corrections are applied to the matrix if they were
            %   selected. Can only be used with implementation 1.
            % Inputs:
            %   obj = The projectorClass object created by
            %   projectorClass
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            % Output:
            %   A = The TRANSPOSE of the system matrix for the current
            %   subset or the entire system matrix if subsets are set to 1
            %   or omitted.
            if obj.param.implementation ~= 1
                error('Implementation not set to 1. Rerun the class constructor with implementation set to 1.')
            end
            if nargin >= 2 && ~isempty(varargin{1})
                obj.subset = varargin{1};
                if obj.subset <= 0
                    obj.param.useSubsets = false;
                    obj.subset = 1;
                else
                    obj.param.useSubsets = true;
                end
            elseif obj.param.subsets == 1 || isempty(obj.param.subsets)
                obj.subset = 1;
                obj.param.useSubsets = false;
            elseif obj.param.subsets > 1 && ~isempty(obj.subset) && obj.subset > 0
                obj.param.useSubsets = true;
            else
                obj.subset = 1;
                obj.param.useSubsets = false;
            end
            if nargin >= 3 && ~isempty(varargin{2}) && varargin{2} > 0
                ii = varargin{2};
            else
                ii = 1;
            end
            if nargin >= 4 && ~isempty(varargin{3})
                corrVec = varargin{3};
            else
                corrVec = cast([], obj.param.cType);
            end
            if obj.param.verbose > 1
                disp('Computing the system matrix')
            end
            if obj.param.useSubsets
                [m_size, xy_index_input, z_index_input, L_input, lor_input, lor2, norm_input, corr_input] = splitInput(obj.param, obj.nMeas, obj.subset, obj.param.xy_index, obj.param.z_index, obj.param.LL, ...
                    obj.param.lor_a, corrVec);
                [~, A] = forwardProjection(obj.param, [], obj.x, obj.z, m_size, obj.nMeas(obj.subset), xy_index_input, z_index_input, norm_input, corr_input, L_input, obj.param.TOF, lor2, lor_input, obj.param.summa(obj.subset), ii, obj.subset - 1);
            else
                if exist('OCTAVE_VERSION','builtin') == 0
                    lor2 = [uint64(0);cumsum(uint64(obj.param.lor_a))];
                else
                    lor2 = [uint64(0);cumsum(uint64(obj.param.lor_a),'native')];
                end
                [~, A] = forwardProjection(obj.param, [], obj.x, obj.z, obj.param.totMeas, obj.nMeas(obj.subset), obj.param.xy_index, obj.param.z_index, obj.param.normalization, corrVec, obj.param.LL, obj.param.TOF, lor2, ...
                    obj.param.lor_a, sum(obj.param.summa), ii, obj.subset - 1);
            end
            if obj.param.verbose > 0
                disp('System matrix computed')
            end
        end
        function obj = transpose(obj)
            obj.trans = true;
        end
        function obj = ctranspose(obj)
            obj.trans = true;
        end
    end
end

